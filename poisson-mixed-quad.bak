// ================================================
// solve 
// \vec{u} + \nabla p = 0
// \nabla \cdot \vec{u} = f
// using RT0/DG0 BDFM1/DG0 on quad meshes.
// ================================================
#include <iostream>
#include <vector>
#include <Eigen/Dense>
#include <petscksp.h>

#define N 4
#define h (1.0/N)
#define area h*h;
#define First 0
#define Second 1
using namespace std;
using RealMat = Eigen::MatrixXd;
using RealVec = Eigen::VectorXd;
typedef double Coord[2];


class Quad1d {
    public:
        double points[2] = {(1-1/sqrt(3))/2, (1+1/sqrt(3))/2};
        double weights[2] = {0.5, 0.5};
};
class Quad2d {
    public:
        Quad1d quad1d;
        double points[4][2] = {
            {quad1d.points[0], quad1d.points[0]},
            {quad1d.points[1], quad1d.points[0]},
            {quad1d.points[0], quad1d.points[1]},
            {quad1d.points[1], quad1d.points[1]}
        };

        double weights[4] = {0.25, 0.25, 0.25, 0.25};
};


class Elem {
    public:
        Elem(int i, int j) : x_left(i*h), x_right((i+1)*h), y_down(j*h), y_up((j+1)*h) {
            x_center = (x_left + x_right) / 2;
            y_center = (y_down + y_up) / 2;
        }
        int i, j;
        double x_left;
        double x_right;
        double x_center;
        double y_down;
        double y_up;
        double y_center;
};


int map_u(int i, int j, int ibas) {
    int idof_global;
    switch (ibas) {
        case 0:
            idof_global = N*(N+1) + j*N + i;
            break;
        case 1:
            idof_global = j*(N+1) + (i+1);
            break;
        case 2:
            idof_global = N*(N+1) + (j+1)*N + i;
            break;
        case 3:
            idof_global = j*(N+1) + i;
            break;
    }
    return idof_global;
}


int map_p(int i, int j) {
    return (2*N*(N+1) + j*N + i);
}


class FERT0 {
    public:
        FERT0();
        void CalcShapeRef(const double *ip, RealMat &shape) const;
        void CalcShape(const Elem &e, const double *ip, RealMat &shape);
        void CalcDivShapeRef(const double *ip, RealVec &divshape) const;
        void CalcDivShape(const Elem &e, const double *ip, RealVec &divshape);
        Coord *nodes = nullptr; 
        Eigen::PartialPivLU<RealMat> Ti;
        const int nbas = 4;
        const double nk[8] =
        { 0., -1.,
          1.,  0.,
          0.,  1.,
         -1.,  0. };
        vector<int> dof2nk;
};


FERT0::FERT0() {
    nodes = (Coord *) calloc (nbas, sizeof(Coord));
    dof2nk.resize(nbas);
    int o = 0;
    nodes[o][0] = 1./2.; nodes[o][1] = 0.0;   dof2nk[o++] = 0;
    nodes[o][0] = 1.;    nodes[o][1] = 1./2.; dof2nk[o++] = 1;
    nodes[o][0] = 1./2.; nodes[o][1] = 1.0;   dof2nk[o++] = 2;
    nodes[o][0] = 0.;    nodes[o][1] = 1./2.; dof2nk[o++] = 3;
    RealMat T(nbas, nbas);
    for (int k = 0; k < nbas; k++) {
        const double *ip = nodes[k];
        const double *n_k = nk + 2*dof2nk[k];

        o = 0;
        T(o++,k) = n_k[0];
        T(o++,k) = n_k[1];
        T(o++,k) = ip[0] * n_k[0];
        T(o++,k) = ip[1] * n_k[1];
    }
    Ti = Eigen::PartialPivLU<RealMat> (T);
#if 0
    for (int i = 0; i < nbas; i++) {
        for (int j = 0; j < nbas; j++) {
            cout << T(i,j) << "\t";
        }
        cout << endl;
    }
#endif
}


void FERT0::CalcShapeRef(const double *ip, RealMat &shape) const {
    RealMat u(nbas,2);
    int o = 0;
    u(o,0) = 1; u(o,1) = 0;
    o++;
    u(o,0) = 0; u(o,1) = 1;
    o++;
    u(o,0) = ip[0]; u(o,1) = 0;
    o++;
    u(o,0) = 0; u(o,1) = ip[1];
    o++;
    assert(o == nbas);

    shape = Ti.solve(u);
}


void FERT0::CalcShape(const Elem &e, const double *ip, RealMat &shape) {
    CalcShapeRef(ip, shape);
}


void FERT0::CalcDivShapeRef(const double *ip, RealVec &divshape) const {
    int o = 0; 
    RealVec divu(nbas);
    divu(o++) = 0; 
    divu(o++) = 0; 
    divu(o++) = 1; 
    divu(o++) = 1; 
    assert(o == nbas);

    divshape = Ti.solve(divu);
}

void FERT0::CalcDivShape(const Elem &e, const double *ip, RealVec &divshape) {
    CalcDivShapeRef(ip, divshape);
}


class FEDG0 {
    public:
        FEDG0();
        void CalcShapeRef(const double *ip, RealVec &shape) const;
        void CalcShape(const Elem &e, const double *ip, RealVec &shape);
        void CalcGradShapeRef(const double *ip, RealMat &gradshape) const;
        void CalcGradShape(const Elem &e, const double *ip, RealMat &gradshape);
        Coord *nodes = nullptr;
        
};

FEDG0::FEDG0() {
    nodes = (Coord *) calloc (1, sizeof(Coord));
    nodes[First][0] = 1./2.;
    nodes[First][1] = 1./2.;
}



void FEDG0::CalcShapeRef(const double *ip, RealVec &shape) const {
    assert(shape.size() == 1);
    shape(First) = 1.;
}


void FEDG0::CalcShape(const Elem &e, const double *ip, RealVec &shape) {
    assert(shape.size() == 1);
    shape(First) = 1.;
}


void FEDG0::CalcGradShapeRef(const double *ip, RealMat &gradshape) const {
    assert(gradshape.rows() == 1);
    gradshape(First, 0) = 0.;
    gradshape(First, 1) = 0.;
}


void FEDG0::CalcGradShape(const Elem &e, const double *ip, RealMat &gradshape) {
    assert(gradshape.rows() == 1);
    gradshape(First, 0) = 0.;
    gradshape(First, 1) = 0.;
}


class Solver {
    public:
        void init();
        void build_mat();
        void build_rhs();
        void solve();
        void step();
        Mat mat = nullptr;
        Vec rhs = nullptr;
        KSP ksp = nullptr;
        Vec x = nullptr;
        Vec x0 = nullptr;
        FERT0 *u;
        FEDG0 *p;
        Quad2d quad2d;
};

void Solver::init() {
    cout << "Solver Init\n";
    cout << "u_space: RT0\n";
    cout << "p_space: DG0\n";
    /* FERT0 *u; */
    /* FEDG0 *p; */


}

void Solver::build_mat() {
    cout << "Build Mat\n";
    int Nu = 4;
    int Np = 1;
    int Ndof = Nu + Np;
    int Id[Ndof];
    int *Iu = Id, *Ip = Iu + Nu;

    RealMat A(Ndof,Ndof);
    RealMat u_shape(Nu,2), dp_shape(Np,2);
    RealVec p_shape(Np),   divu_shape(Nu);
    for (int i = 0; i < N; i++) { // iter elem
        for (int j = 0; j < N; j++) { // iter elem
            Elem e(i,j);
            for (int k = 0; k < Nu; k++) { // map dof
                Iu[k] = map_u(i,j,k);
            }
            Ip[0] = map_p(i,j); // map dof

            A.setZero();
            for (int k = 0; k < 4; k++) { // iter quad points
                u->CalcShape(e, quad2d.points[k], u_shape);
                u->CalcDivShape(e, quad2d.points[k], divu_shape);
                p->CalcShape(e, quad2d.points[k], p_shape);
                p->CalcGradShape(e, quad2d.points[k], dp_shape);
                for (int m = 0; m < Nu; m++) {
                    // A(u,v)
                    for (int n = 0; n < Nu; n++) {
                        A(m,n) += quad2d.weights[k] * area * (u_shape(m,0)*u_shape(n,0) + u_shape(m,1)*u_shape(n,1));
                    }
                    // A(p,v)
                    for (int n = 0; n < Np; n++) {
                        A(m,n+Nu) += quad2d.weights[k] * area * (-divu_shape(m) * p_shape(n));
                    }
                }
                // A(q,u) 
                for (int m = 0; m < Np; m++) {
                    for (int n = 0; n < Nu; n++) {
                        A(m + Nu, n) += quad2d.weights[k] * area * (p_shape(m) * divu_shape(n));
                    }
                }

            } // end iter quad points
            
            // u's Dirich as Neumann
            if (i == 0) {
                A(3,3) = 1;
            }
            if (i == N-1) {
                A(1,1) = 1;
            }
            if (j == 0) {
                A(0,0) = 1;
            }
            if (j == N-1) {
                A(2,2) = 1;
            }

            // Add element matrix
            for (int m = 0; m < Ndof; m++) {
                RealVec Ai = A.row(m);
                MatSetValues(mat, 1, &Id[m], Ndof, Id, &Ai[0], ADD_VALUES);
            }

        } // end iter elem
    } // end iter elem

    MatAssemblyBegin(mat, MAT_FINAL_ASSEMBLY);
    MatAssemblyEnd(mat, MAT_FINAL_ASSEMBLY);

    /* for (int i = 0; i < 2*N*(N+1)+N*N; i++) { */
    /*     for (int j = 0; j < 2*N*(N+1)+N*N; j++) { */
    /*         cout << mat */
    /*     } */
    /* } */
	PetscViewer viewer;
    PetscViewerASCIIOpen(PETSC_COMM_WORLD,  "A_.m",  &viewer);
    PetscViewerPushFormat(viewer,  PETSC_VIEWER_ASCII_MATLAB);
    PetscObjectSetName((PetscObject)mat, "A");
    MatView(mat, viewer);
    PetscViewerPopFormat(viewer);
    PetscViewerDestroy(&viewer);

    cout << "Build Mat Done\n";
}



void Solver::build_rhs() {
    cout << "Build Rhs\n";
}
void Solver::solve() {
    cout << "Solve Use Petsc\n";
}
void Solver::step() {
    build_mat();
    build_rhs();
    solve();
}








int main(int argc, char* argv[]) {
    FERT0 *u;
    FEDG0 *p;

    Solver solver;
    solver.build_mat();

    /* PetscInitialize(&argc, &argv, NULL, NULL); */
    /* // ... 其他代码 ... */
    /* Mat A; */
    /* PetscInt n = 10; // 矩阵维度 */
    /* MatCreate(PETSC_COMM_WORLD, &A); */
    /* MatSetSizes(A, PETSC_DECIDE, PETSC_DECIDE, n, n); */
    /* MatSetFromOptions(A); // 允许通过命令行选项设置矩阵类型 */
    /* MatSetUp(A); */

    /* // 填充矩阵（示例：三对角矩阵） */
    /* PetscInt i, col[3]; */
    /* PetscScalar value[3]; */
    /* for (i = 1; i < n-1; i++) { */
    /*     col[0] = i-1; col[1] = i; col[2] = i+1; */
    /*     value[0] = -1.0; value[1] = 2.0; value[2] = -1.0; */
    /*     MatSetValues(A, 1, &i, 3, col, value, INSERT_VALUES); */
    /* } */
    /* MatAssemblyBegin(A, MAT_FINAL_ASSEMBLY); */
    /* MatAssemblyEnd(A, MAT_FINAL_ASSEMBLY); */

    /* Vec x, b; */
    /* VecCreate(PETSC_COMM_WORLD, &x); */
    /* VecSetSizes(x, PETSC_DECIDE, n); */
    /* VecSetFromOptions(x); */
    /* VecDuplicate(x, &b); // b 和 x 同尺寸 */

    /* // 填充向量 b（示例：全1向量） */
    /* PetscScalar one = 1.0; */
    /* VecSet(b, one); */

    /* KSP ksp; */
    /* KSPCreate(PETSC_COMM_WORLD, &ksp); */
    /* KSPSetOperators(ksp, A, A); // 设置矩阵 A */
    /* KSPSetFromOptions(ksp);     // 允许通过命令行选项配置求解器 */

    /* KSPSolve(ksp, b, x); // 解 Ax = b，结果存储在 x 中 */
    /* VecView(x, PETSC_VIEWER_STDOUT_WORLD); */








    /* /1* Elem e; *1/ */
    /* /1* RealMat mat; *1/ */
    /* /1* RealVec vec; *1/ */


    /* /1*     for (int i = 0; i < N; i++) { *1/ */
    /* /1*         for (int j = 0; j < N; j++) { *1/ */
    /* /1*             e = Elem(i, j); *1/ */

    /* /1*         } *1/ */
    /* /1*     } *1/ */

    /* PetscFinalize(); */
}
